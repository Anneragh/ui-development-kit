<div *ngIf="isReady" class="autosave-controls" style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; padding: 1rem; background: #f5f5f5; border-radius: 4px;">
  
  <!-- Auto-save status -->
  <div class="autosave-status" style="display: flex; align-items: center; gap: 0.5rem;">
    <mat-icon [style.color]="isSaving ? 'orange' : (hasLocalChanges() ? 'red' : 'green')">
      {{ isSaving ? 'sync' : (hasLocalChanges() ? 'cloud_off' : 'cloud_done') }}
    </mat-icon>
    <span class="status-text">
      <ng-container *ngIf="isSaving">Saving...</ng-container>
      <ng-container *ngIf="!isSaving && hasLocalChanges()">
        Has unsaved changes
        <!-- <span *ngIf="lastAutoSave" style="color: #666; font-size: 0.9em;">(saved {{ lastAutoSave }})</span> -->
      </ng-container>
      <ng-container *ngIf="!isSaving && !hasLocalChanges()">All changes saved</ng-container>
    </span>
  </div>

  <!-- Sync controls -->
  <div class="sync-controls" style="margin-left: auto; display: flex; gap: 1rem;">
    <button 
      mat-stroked-button 
      color="warn" 
      (click)="discardLocalChanges()"
      [disabled]="!hasLocalChanges() || isSyncing"
      *ngIf="hasLocalChanges()">
      <mat-icon>delete</mat-icon>
      Discard Changes
    </button>
    
    <button 
    mat-raised-button 
    color="accent" 
    (click)="downloadTransform()"
    [disabled]="!definition?.sequence?.[0]"
    matTooltip="Download Transform Definition">
    <mat-icon>download</mat-icon>
    Download
  </button>

    <button 
      mat-raised-button 
      color="primary" 
      (click)="saveToCloud()"
      [matBadge]="hasLocalChanges() ? '!' : null"
      matBadgeColor="warn"
      matBadgeSize="small">
      <mat-icon>{{ isSyncing ? 'sync' : 'cloud_upload' }}</mat-icon>
      {{ isSyncing ? 'Syncing...' : (isNewTransform ? 'Create Transform' : 'Save') }}
    </button>
  </div>
</div>

  <button class="preview-button" mat-raised-button color="primary" (click)="togglePreview()">
		Preview Transform
  </button>

  <mat-card appearance="outlined" class="transform-name">
    <mat-card-content>{{definition?.properties?.name}}
      <mat-icon 
      *ngIf="hasLocalChanges()" 
      style="color: orange; margin-left: 0.5rem; font-size: 16px; width: 16px; height: 16px;"
      matTooltip="This transform has unsaved local changes">
      edit
    </mat-icon>
    </mat-card-content>
  </mat-card>

<div *ngIf="!isReady" class="spinner-container">
  <mat-spinner diameter="75"></mat-spinner>
</div>

<sqd-designer *ngIf="isReady"
  theme="light"
  [definition]="definition"
  [toolboxConfiguration]="toolboxConfiguration"
  [stepsConfiguration]="stepsConfiguration"
  [validatorConfiguration]="validatorConfiguration"
  [controlBar]="true"
  [isReadonly]="isReadonly"
  [areEditorsHidden]="false"
  [rootEditor]="rootEditorProvider"
  [stepEditor]="stepEditorProvider"
  [isToolboxCollapsed]="isToolboxCollapsed"
  [isEditorCollapsed]="isEditorCollapsed"
  [undoStackSize]="5"
  (onReady)="onDesignerReady($event)"
  (onDefinitionChanged)="onDefinitionChanged($event)"
>
</sqd-designer>

<ng-template #rootEditorProvider let-editor>
	<h3>Transform</h3>

	<mat-form-field class="full-width">
		<input
			matInput
      [(ngModel)]="editor.definition.properties.name"
			[value]="editor.definition.properties.name"
			[readonly]="editor.isReadonly"
			(input)="updateProperty(editor.definition.properties, 'name', $event, editor.context)"
		/>
	</mat-form-field>
</ng-template>

<ng-template #stepEditorProvider let-editor>
    <div style="padding: 1rem;">
        <h3>{{editor.step.name}}</h3>
    
        <p>Attributes</p>
        <ng-container *ngFor="let key of objectKeys(editor.step.properties)">
          <div *ngIf="isBoolean(editor.step.properties[key]); else numberCheck" style="display: block; margin-top: 1rem;">
            <mat-slide-toggle [(ngModel)]="editor.step.properties[key]" name="{{ key }}"
                              [disabled]="editor.isReadonly"
                              (change)="updateProperty(editor.step.properties, key, $event, editor.context)">
              {{ key }}
            </mat-slide-toggle>
          </div>

          <!-- Number handling -->
          <ng-template #numberCheck>
            <div *ngIf="isNumber(editor.step.properties[key]); else fieldCheck" style="display: block; margin-top: 1rem;">
              <mat-form-field appearance="fill">
                <mat-label>{{ key }}</mat-label>
                <input matInput 
                       type="number" 
                       [(ngModel)]="editor.step.properties[key]" 
                       name="{{ key }}"
                       [readonly]="editor.isReadonly"
                       [required]="isRequired(editor.step.type, key)"
                       (input)="updateProperty(editor.step.properties, key, $event, editor.context)">
                <mat-error *ngIf="editor.step.properties[key] === null || editor.step.properties[key] === undefined">
                  {{ key }} is required
                </mat-error>
              </mat-form-field>
            </div>
          </ng-template>
        
          <ng-template #fieldCheck>
            <div *ngIf="isMap(editor.step.properties[key]); else textField" style="display: block; margin-top: 1rem;">
              <button mat-raised-button color="primary" (click)="editMap(editor.step.properties, key, editor.context)">
                Edit {{ key }}
              </button>
            </div>
          </ng-template>
        
          <ng-template #textField>
            <!-- Special handling for sourceName -->
            <ng-container *ngIf="key === 'sourceName' && editor.step.type === 'accountAttribute'">
              <mat-form-field appearance="fill" style="display: block; margin-top: 1rem;">
                <mat-label>{{ key }}</mat-label>
                <mat-select [(ngModel)]="editor.step.properties[key]" 
                           [disabled]="editor.isReadonly" 
                           [required]="isRequired(editor.step.type, key)" 
                           name="{{ key }}"
                           (selectionChange)="onSourceNameChanged(editor.step.properties, key, $event.value, editor.context)">
                  <mat-option *ngFor="let choice of getChoicesForProperty(editor.step.type, key)" [value]="choice">
                    {{ getChoiceLabel(editor.step.type, choice) }}
                  </mat-option>
                </mat-select>
                <mat-error *ngIf="editor.step.properties[key] === ''">
                  {{ key }} is required
                </mat-error>
              </mat-form-field>
            </ng-container>

            <!-- Special handling for accountAttribute -->
          <ng-container *ngIf="key === 'attributeName' && editor.step.type === 'accountAttribute'">
            <mat-form-field appearance="fill" style="display: block; margin-top: 1rem;">
              <mat-label>{{ key }}</mat-label>
              <mat-select [(ngModel)]="editor.step.properties[key]" 
                        [disabled]="editor.isReadonly || isAccountAttributeDisabled(editor)" 
                        [required]="isRequired(editor.step.type, key)" 
                        name="{{ key }}"
                        (selectionChange)="updateProperty(editor.step.properties, key, $event.value, editor.context)">
                <!-- Fixed: Use attr directly as both value and display text -->
                <mat-option *ngFor="let attr of getAccountAttributes(editor)" [value]="attr">
                  {{ attr }}
                </mat-option>
              </mat-select>
              <mat-hint *ngIf="isLoadingAccountAttributes(editor)">Loading attributes...</mat-hint>
              <mat-hint *ngIf="!editor.step.properties['sourceName'] && !isLoadingAccountAttributes(editor)">
                Please select a source name first
              </mat-hint>
              <mat-error *ngIf="editor.step.properties[key] === ''">
                {{ key }} is required
              </mat-error>
            </mat-form-field>
          </ng-container>

          <ng-container *ngIf="key === 'inputFormat' && editor.step.type === 'dateFormat'">
              <!-- Help section with common patterns -->
              
                <mat-form-field appearance="fill" style="display: block; margin-top: 1rem;">
                  <mat-label>{{ key }}</mat-label>
                  <mat-select [(ngModel)]="editor.step.properties[key]" 
                            [disabled]="editor.isReadonly" 
                            [required]="isRequired(editor.step.type, key)" 
                            name="{{ key }}"
                            (selectionChange)="updateProperty(editor.step.properties, key, $event.value, editor.context)">
                    <mat-option *ngFor="let choice of getChoicesForProperty(editor.step.type, key)" [value]="choice">
                      {{ getChoiceLabel(editor.step.type, choice) }}
                    </mat-option>
                  </mat-select>
                  <mat-error *ngIf="editor.step.properties[key] === ''">
                    {{ key }} is required
                  </mat-error>
                </mat-form-field>
                
                <!-- Custom Input Format Field -->
                <div *ngIf="editor.step.properties['inputFormat'] === 'CUSTOM'" style="margin-top: 0.5rem;">
                  <mat-form-field appearance="fill" style="width: 100%;">
                    <mat-label>Custom Input Format</mat-label>
                    <input matInput 
                          [(ngModel)]="editor.step.properties['customInputFormat']"
                          [readonly]="editor.isReadonly"
                          [required]="true"
                          placeholder="e.g., yyyy-MM-dd HH:mm:ss"
                          (input)="updateProperty(editor.step.properties, 'customInputFormat', $event, editor.context)">
                    <mat-error *ngIf="editor.step.properties['customInputFormat'] === ''">
                      Custom input format is required when using CUSTOM
                    </mat-error>
                  </mat-form-field>
                  
                  <!-- Preview for custom input format -->
                  <div *ngIf="editor.step.properties['customInputFormat']" 
                      style="margin-top: 0.5rem; padding: 0.5rem; background: #f5f5f5; border-radius: 4px; font-size: 0.875rem;">
                    {{ getDateFormatExample(editor.step.properties['customInputFormat']) }}
                  </div>
                </div>
              </ng-container>

              <!-- Output Format handling -->
              <ng-container *ngIf="key === 'outputFormat' && editor.step.type === 'dateFormat'">
                <!-- Check if it's a choice field first -->
                <mat-form-field appearance="fill" style="display: block; margin-top: 1rem;">
                  <mat-label>{{ key }}</mat-label>
                  <mat-select [(ngModel)]="editor.step.properties[key]" 
                            [disabled]="editor.isReadonly" 
                            [required]="isRequired(editor.step.type, key)" 
                            name="{{ key }}"
                            (selectionChange)="updateProperty(editor.step.properties, key, $event.value, editor.context)">
                    <mat-option *ngFor="let choice of getChoicesForProperty(editor.step.type, key)" [value]="choice">
                      {{ getChoiceLabel(editor.step.type, choice) }}
                    </mat-option>
                  </mat-select>
                  <mat-error *ngIf="editor.step.properties[key] === ''">
                    {{ key }} is required
                  </mat-error>
                </mat-form-field>
                
                <!-- Custom Output Format Field -->
                <div *ngIf="editor.step.properties['outputFormat'] === 'CUSTOM'" style="margin-top: 0.5rem;">
                  <mat-form-field appearance="fill" style="width: 100%;">
                    <mat-label>Custom Output Format</mat-label>
                    <input matInput 
                          [(ngModel)]="editor.step.properties['customOutputFormat']"
                          [readonly]="editor.isReadonly"
                          [required]="true"
                          placeholder="e.g., dd/MM/yyyy HH:mm"
                          (input)="updateProperty(editor.step.properties, 'customOutputFormat', $event, editor.context)">
                    <mat-hint>Use Java SimpleDateFormat pattern (e.g., dd/MM/yyyy, MMM dd, yyyy)</mat-hint>
                    <mat-error *ngIf="editor.step.properties['customOutputFormat'] === ''">
                      Custom output format is required when using CUSTOM
                    </mat-error>
                  </mat-form-field>
                  
                  <!-- Preview for custom output format -->
                  <div *ngIf="editor.step.properties['customOutputFormat']" 
                      style="margin-top: 0.5rem; padding: 0.5rem; background: #f5f5f5; border-radius: 4px; font-size: 0.875rem;">
                    <strong>Example:</strong> {{ getDateFormatExample(editor.step.properties['customOutputFormat']) }}
                  </div>
                </div>
                <div *ngIf="(editor.step.properties['inputFormat'] === 'CUSTOM' || editor.step.properties['outputFormat'] === 'CUSTOM')" 
                    style="margin-top: 1rem; margin-bottom: 1rem; padding: 1rem; background: #e3f2fd; border-radius: 4px; border-left: 4px solid #2196f3;">
                  <h4 style="margin: 0 0 0.5rem 0; color: #1976d2; font-size: 0.875rem;">Common Date Format Patterns</h4>
                  <div style="font-size: 0.75rem; color: #424242;">
                    <div><code>yyyy-MM-dd</code> → 2024-03-15</div>
                    <div><code>MM/dd/yyyy</code> → 03/15/2024</div>
                    <div><code>dd/MM/yyyy</code> → 15/03/2024</div>
                    <div><code>MMM dd, yyyy</code> → Mar 15, 2024</div>
                    <div><code>yyyy-MM-dd HH:mm:ss</code> → 2024-03-15 14:30:45</div>
                    <div><code>HH:mm:ss</code> → 14:30:45</div>
                  </div>
                </div>
              </ng-container>

            <!-- Default handling for other properties -->
            <ng-container *ngIf="key !== 'sourceName' && key !== 'attributeName' && key !== 'inputFormat' && key !== 'outputFormat' && key !== 'customInputFormat' && key !== 'customOutputFormat'">
              <ng-container *ngIf="getChoicesForProperty(editor.step.type, key) as choices; else defaultInput">
                <mat-form-field appearance="fill" style="display: block; margin-top: 1rem;">
                  <mat-label>{{ key }}</mat-label>
                  <mat-select [(ngModel)]="editor.step.properties[key]" [disabled]="editor.isReadonly" [required]="isRequired(editor.step.type, key)" name="{{ key }}"
                              (selectionChange)="updateProperty(editor.step.properties, key, $event.value, editor.context)">
                    <mat-option *ngFor="let choice of choices" [value]="choice">{{ getChoiceLabel(editor.step.type, choice) }}</mat-option>
                  </mat-select>
                  <mat-error *ngIf="editor.step.properties[key] === ''">
                    {{ key }} is required
                  </mat-error>
                </mat-form-field>
              </ng-container>
          
              <ng-template #defaultInput>
                <mat-form-field appearance="fill" style="display: block; margin-top: 1rem;">
                  <mat-label>{{ key }}</mat-label>
                  <input matInput [(ngModel)]="editor.step.properties[key]" name="{{ key }}"
                         [readonly]="editor.isReadonly"
                         [required]="isRequired(editor.step.type, key)"
                         (input)="updateProperty(editor.step.properties, key, $event, editor.context)">
                         <mat-error *ngIf="editor.step.properties[key] === ''">
                          {{ key }} is required
                        </mat-error>
                </mat-form-field>
              </ng-template>
            </ng-container>
          </ng-template>
        </ng-container>
        
          <div *ngIf="editor?.step?.branches">
            <div *ngFor="let branchName of getBranchNames(editor.step.branches); let i = index" class="branch-row">
              <div *ngIf="showBranch(editor?.step, branchName)">
              <mat-form-field appearance="outline" class="branch-field">
                <input matInput [value]="branchName" [readonly]="editor.isReadonly" placeholder="Branch Name" (change)="renameBranchAtIndex(editor.step.branches, branchName, $any($event.target).value, editor.context)"/>
              </mat-form-field>
              <button mat-icon-button color="warn" (click)="removeBranch(editor.step.branches, i, $event, editor.context)">
                <mat-icon>delete</mat-icon>
              </button>
            </div>
            </div>
        
            <button mat-stroked-button color="primary" (click)="addBranch(editor.step.branches, editor.context)" *ngIf="branchingEnabled(editor.step)">
              <mat-icon>add</mat-icon>
              Add Branch
            </button>
        </div>
      </div>
  </ng-template>